// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CLIENTMESSAGES_NETWORK_MESSAGES_CLIENT_H_
#define FLATBUFFERS_GENERATED_CLIENTMESSAGES_NETWORK_MESSAGES_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

#include "Shared_generated.h"

namespace network {
namespace messages {
struct Vec3;
struct Vec2;
}  // namespace messages
}  // namespace network

namespace network {
namespace messages {
namespace client {

struct UserConnect;
struct UserConnected;
struct UserDisconnect;
struct Attack;
struct Move;
struct ClientMessage;

/// The move direction is a bit mask of the keys that the client currently holds pressed
enum MoveDirection {
  MoveDirection_MOVEFORWARD = 2,
  MoveDirection_MOVEBACKWARD = 4,
  MoveDirection_MOVELEFT = 8,
  MoveDirection_MOVERIGHT = 16
};

inline const char **EnumNamesMoveDirection() {
  static const char *names[] = { "MOVEFORWARD", "", "MOVEBACKWARD", "", "", "", "MOVELEFT", "", "", "", "", "", "", "", "MOVERIGHT", nullptr };
  return names;
}

inline const char *EnumNameMoveDirection(MoveDirection e) { return EnumNamesMoveDirection()[e - MoveDirection_MOVEFORWARD]; }

enum Type {
  Type_NONE = 0,
  Type_UserConnect = 1,
  Type_UserConnected = 2,
  Type_UserDisconnect = 3,
  Type_Attack = 4,
  Type_Move = 5
};

inline const char **EnumNamesType() {
  static const char *names[] = { "NONE", "UserConnect", "UserConnected", "UserDisconnect", "Attack", "Move", nullptr };
  return names;
}

inline const char *EnumNameType(Type e) { return EnumNamesType()[e]; }

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *union_obj, Type type);

struct UserConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *email() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *password() const { return GetPointer<const flatbuffers::String *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 4 /* email */) &&
           verifier.Verify(email()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 6 /* password */) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
};

struct UserConnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_email(flatbuffers::Offset<flatbuffers::String> email) { fbb_.AddOffset(4, email); }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) { fbb_.AddOffset(6, password); }
  UserConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UserConnectBuilder &operator=(const UserConnectBuilder &);
  flatbuffers::Offset<UserConnect> Finish() {
    auto o = flatbuffers::Offset<UserConnect>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, 4);  // email
    fbb_.Required(o, 6);  // password
    return o;
  }
};

inline flatbuffers::Offset<UserConnect> CreateUserConnect(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> email = 0,
   flatbuffers::Offset<flatbuffers::String> password = 0) {
  UserConnectBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_email(email);
  return builder_.Finish();
}

/// a message that the client is sending once the connection is successful and it is
/// ready to receive more data
struct UserConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UserConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  UserConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UserConnectedBuilder &operator=(const UserConnectedBuilder &);
  flatbuffers::Offset<UserConnected> Finish() {
    auto o = flatbuffers::Offset<UserConnected>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<UserConnected> CreateUserConnected(flatbuffers::FlatBufferBuilder &_fbb) {
  UserConnectedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UserDisconnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UserDisconnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  UserDisconnectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UserDisconnectBuilder &operator=(const UserDisconnectBuilder &);
  flatbuffers::Offset<UserDisconnect> Finish() {
    auto o = flatbuffers::Offset<UserDisconnect>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<UserDisconnect> CreateUserDisconnect(flatbuffers::FlatBufferBuilder &_fbb) {
  UserDisconnectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Attack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int64_t targetId() const { return GetField<int64_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* targetId */) &&
           verifier.EndTable();
  }
};

struct AttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targetId(int64_t targetId) { fbb_.AddElement<int64_t>(4, targetId, 0); }
  AttackBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AttackBuilder &operator=(const AttackBuilder &);
  flatbuffers::Offset<Attack> Finish() {
    auto o = flatbuffers::Offset<Attack>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Attack> CreateAttack(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t targetId = 0) {
  AttackBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  return builder_.Finish();
}

struct Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  MoveDirection direction() const { return static_cast<MoveDirection>(GetField<uint8_t>(4, 0)); }
  /// vertical
  float pitch() const { return GetField<float>(6, 0); }
  /// horizontal
  float yaw() const { return GetField<float>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* direction */) &&
           VerifyField<float>(verifier, 6 /* pitch */) &&
           VerifyField<float>(verifier, 8 /* yaw */) &&
           verifier.EndTable();
  }
};

struct MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_direction(MoveDirection direction) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(direction), 0); }
  void add_pitch(float pitch) { fbb_.AddElement<float>(6, pitch, 0); }
  void add_yaw(float yaw) { fbb_.AddElement<float>(8, yaw, 0); }
  MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MoveBuilder &operator=(const MoveBuilder &);
  flatbuffers::Offset<Move> Finish() {
    auto o = flatbuffers::Offset<Move>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Move> CreateMove(flatbuffers::FlatBufferBuilder &_fbb,
   MoveDirection direction = static_cast<MoveDirection>(0),
   float pitch = 0,
   float yaw = 0) {
  MoveBuilder builder_(_fbb);
  builder_.add_yaw(yaw);
  builder_.add_pitch(pitch);
  builder_.add_direction(direction);
  return builder_.Finish();
}

struct ClientMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  Type data_type() const { return static_cast<Type>(GetField<uint8_t>(4, 0)); }
  const void *data() const { return GetPointer<const void *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* data_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* data */) &&
           VerifyType(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct ClientMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(Type data_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(6, data); }
  ClientMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ClientMessageBuilder &operator=(const ClientMessageBuilder &);
  flatbuffers::Offset<ClientMessage> Finish() {
    auto o = flatbuffers::Offset<ClientMessage>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ClientMessage> CreateClientMessage(flatbuffers::FlatBufferBuilder &_fbb,
   Type data_type = Type_NONE,
   flatbuffers::Offset<void> data = 0) {
  ClientMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *union_obj, Type type) {
  switch (type) {
    case Type_NONE: return true;
    case Type_UserConnect: return verifier.VerifyTable(reinterpret_cast<const UserConnect *>(union_obj));
    case Type_UserConnected: return verifier.VerifyTable(reinterpret_cast<const UserConnected *>(union_obj));
    case Type_UserDisconnect: return verifier.VerifyTable(reinterpret_cast<const UserDisconnect *>(union_obj));
    case Type_Attack: return verifier.VerifyTable(reinterpret_cast<const Attack *>(union_obj));
    case Type_Move: return verifier.VerifyTable(reinterpret_cast<const Move *>(union_obj));
    default: return false;
  }
}

inline const ClientMessage *GetClientMessage(const void *buf) { return flatbuffers::GetRoot<ClientMessage>(buf); }

inline bool VerifyClientMessageBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<ClientMessage>(); }

inline void FinishClientMessageBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ClientMessage> root) { fbb.Finish(root); }

}  // namespace client
}  // namespace messages
}  // namespace network

#endif  // FLATBUFFERS_GENERATED_CLIENTMESSAGES_NETWORK_MESSAGES_CLIENT_H_
