// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SERVERMESSAGES_NETWORK_MESSAGES_SERVER_H_
#define FLATBUFFERS_GENERATED_SERVERMESSAGES_NETWORK_MESSAGES_SERVER_H_

#include "flatbuffers/flatbuffers.h"

#include "Shared_generated.h"

namespace network {
namespace messages {
struct Vec3;
struct Vec2;
struct IVec2;
}  // namespace messages
}  // namespace network

namespace network {
namespace messages {
namespace server {

struct Seed;
struct AuthFailed;
struct UserSpawn;
struct NpcSpawn;
struct EntityRemove;
struct EntityUpdate;
struct ServerMessage;

enum Type {
  Type_NONE = 0,
  Type_Seed = 1,
  Type_UserSpawn = 2,
  Type_NpcSpawn = 3,
  Type_EntityRemove = 4,
  Type_EntityUpdate = 5,
  Type_AuthFailed = 6
};

inline const char **EnumNamesType() {
  static const char *names[] = { "NONE", "Seed", "UserSpawn", "NpcSpawn", "EntityRemove", "EntityUpdate", "AuthFailed", nullptr };
  return names;
}

inline const char *EnumNameType(Type e) { return EnumNamesType()[e]; }

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *union_obj, Type type);

struct Seed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int64_t seed() const { return GetField<int64_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* seed */) &&
           verifier.EndTable();
  }
};

struct SeedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) { fbb_.AddElement<int64_t>(4, seed, 0); }
  SeedBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SeedBuilder &operator=(const SeedBuilder &);
  flatbuffers::Offset<Seed> Finish() {
    auto o = flatbuffers::Offset<Seed>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Seed> CreateSeed(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t seed = 0) {
  SeedBuilder builder_(_fbb);
  builder_.add_seed(seed);
  return builder_.Finish();
}

struct AuthFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AuthFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  AuthFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AuthFailedBuilder &operator=(const AuthFailedBuilder &);
  flatbuffers::Offset<AuthFailed> Finish() {
    auto o = flatbuffers::Offset<AuthFailed>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<AuthFailed> CreateAuthFailed(flatbuffers::FlatBufferBuilder &_fbb) {
  AuthFailedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UserSpawn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int64_t id() const { return GetField<int64_t>(4, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(6); }
  const network::messages::Vec3 *pos() const { return GetStruct<const network::messages::Vec3 *>(8); }
  float rotation() const { return GetField<float>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<network::messages::Vec3>(verifier, 8 /* pos */) &&
           VerifyField<float>(verifier, 10 /* rotation */) &&
           verifier.EndTable();
  }
};

struct UserSpawnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) { fbb_.AddElement<int64_t>(4, id, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(6, name); }
  void add_pos(const network::messages::Vec3 *pos) { fbb_.AddStruct(8, pos); }
  void add_rotation(float rotation) { fbb_.AddElement<float>(10, rotation, 0); }
  UserSpawnBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UserSpawnBuilder &operator=(const UserSpawnBuilder &);
  flatbuffers::Offset<UserSpawn> Finish() {
    auto o = flatbuffers::Offset<UserSpawn>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<UserSpawn> CreateUserSpawn(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t id = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   const network::messages::Vec3 *pos = 0,
   float rotation = 0) {
  UserSpawnBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_name(name);
  return builder_.Finish();
}

struct NpcSpawn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int64_t id() const { return GetField<int64_t>(4, 0); }
  network::messages::NpcType type() const { return static_cast<network::messages::NpcType>(GetField<int32_t>(6, 0)); }
  const network::messages::Vec3 *pos() const { return GetStruct<const network::messages::Vec3 *>(8); }
  float rotation() const { return GetField<float>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* id */) &&
           VerifyField<int32_t>(verifier, 6 /* type */) &&
           VerifyField<network::messages::Vec3>(verifier, 8 /* pos */) &&
           VerifyField<float>(verifier, 10 /* rotation */) &&
           verifier.EndTable();
  }
};

struct NpcSpawnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) { fbb_.AddElement<int64_t>(4, id, 0); }
  void add_type(network::messages::NpcType type) { fbb_.AddElement<int32_t>(6, static_cast<int32_t>(type), 0); }
  void add_pos(const network::messages::Vec3 *pos) { fbb_.AddStruct(8, pos); }
  void add_rotation(float rotation) { fbb_.AddElement<float>(10, rotation, 0); }
  NpcSpawnBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NpcSpawnBuilder &operator=(const NpcSpawnBuilder &);
  flatbuffers::Offset<NpcSpawn> Finish() {
    auto o = flatbuffers::Offset<NpcSpawn>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<NpcSpawn> CreateNpcSpawn(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t id = 0,
   network::messages::NpcType type = network::messages::NpcType_NONE,
   const network::messages::Vec3 *pos = 0,
   float rotation = 0) {
  NpcSpawnBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_type(type);
  return builder_.Finish();
}

struct EntityRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int64_t id() const { return GetField<int64_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* id */) &&
           verifier.EndTable();
  }
};

struct EntityRemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) { fbb_.AddElement<int64_t>(4, id, 0); }
  EntityRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EntityRemoveBuilder &operator=(const EntityRemoveBuilder &);
  flatbuffers::Offset<EntityRemove> Finish() {
    auto o = flatbuffers::Offset<EntityRemove>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<EntityRemove> CreateEntityRemove(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t id = 0) {
  EntityRemoveBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct EntityUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int64_t id() const { return GetField<int64_t>(4, 0); }
  const network::messages::Vec3 *pos() const { return GetStruct<const network::messages::Vec3 *>(6); }
  float rotation() const { return GetField<float>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* id */) &&
           VerifyFieldRequired<network::messages::Vec3>(verifier, 6 /* pos */) &&
           VerifyField<float>(verifier, 8 /* rotation */) &&
           verifier.EndTable();
  }
};

struct EntityUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) { fbb_.AddElement<int64_t>(4, id, 0); }
  void add_pos(const network::messages::Vec3 *pos) { fbb_.AddStruct(6, pos); }
  void add_rotation(float rotation) { fbb_.AddElement<float>(8, rotation, 0); }
  EntityUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EntityUpdateBuilder &operator=(const EntityUpdateBuilder &);
  flatbuffers::Offset<EntityUpdate> Finish() {
    auto o = flatbuffers::Offset<EntityUpdate>(fbb_.EndTable(start_, 3));
    fbb_.Required(o, 6);  // pos
    return o;
  }
};

inline flatbuffers::Offset<EntityUpdate> CreateEntityUpdate(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t id = 0,
   const network::messages::Vec3 *pos = 0,
   float rotation = 0) {
  EntityUpdateBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct ServerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  Type data_type() const { return static_cast<Type>(GetField<uint8_t>(4, 0)); }
  const void *data() const { return GetPointer<const void *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* data_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* data */) &&
           VerifyType(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct ServerMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(Type data_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(6, data); }
  ServerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ServerMessageBuilder &operator=(const ServerMessageBuilder &);
  flatbuffers::Offset<ServerMessage> Finish() {
    auto o = flatbuffers::Offset<ServerMessage>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ServerMessage> CreateServerMessage(flatbuffers::FlatBufferBuilder &_fbb,
   Type data_type = Type_NONE,
   flatbuffers::Offset<void> data = 0) {
  ServerMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *union_obj, Type type) {
  switch (type) {
    case Type_NONE: return true;
    case Type_Seed: return verifier.VerifyTable(reinterpret_cast<const Seed *>(union_obj));
    case Type_UserSpawn: return verifier.VerifyTable(reinterpret_cast<const UserSpawn *>(union_obj));
    case Type_NpcSpawn: return verifier.VerifyTable(reinterpret_cast<const NpcSpawn *>(union_obj));
    case Type_EntityRemove: return verifier.VerifyTable(reinterpret_cast<const EntityRemove *>(union_obj));
    case Type_EntityUpdate: return verifier.VerifyTable(reinterpret_cast<const EntityUpdate *>(union_obj));
    case Type_AuthFailed: return verifier.VerifyTable(reinterpret_cast<const AuthFailed *>(union_obj));
    default: return false;
  }
}

inline const ServerMessage *GetServerMessage(const void *buf) { return flatbuffers::GetRoot<ServerMessage>(buf); }

inline bool VerifyServerMessageBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<ServerMessage>(); }

inline void FinishServerMessageBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ServerMessage> root) { fbb.Finish(root); }

}  // namespace server
}  // namespace messages
}  // namespace network

#endif  // FLATBUFFERS_GENERATED_SERVERMESSAGES_NETWORK_MESSAGES_SERVER_H_
